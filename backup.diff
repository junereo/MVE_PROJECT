diff --git a/apps/tuner-api/src/services/survey.service.ts b/apps/tuner-api/src/services/survey.service.ts
index 1822af3..a0c4c17 100644
--- a/apps/tuner-api/src/services/survey.service.ts
+++ b/apps/tuner-api/src/services/survey.service.ts
@@ -1,245 +1,253 @@
 import {
-    PrismaClient,
-    SurveyTags,
-    SurveyActive,
-    QuestionType,
-    SurveyType,
-    Prisma,
-} from '@prisma/client';
+  PrismaClient,
+  SurveyTags,
+  SurveyActive,
+  QuestionType,
+  SurveyType,
+  Prisma,
+} from "@prisma/client";
 
 const prisma = new PrismaClient();
 
-// 설문 맵핑 
+// 설문 맵핑
 const convertType = (t: string): QuestionType => {
-    if (t === 'multiple') return 'multiple_choice';
-    if (t === 'checkbox') return 'check_box';
-    if (t === 'subjective') return 'text';
-    return 'text';
+  if (t === "multiple") return "multiple_choice";
+  if (t === "checkbox") return "check_box";
+  if (t === "subjective") return "text";
+  return "text";
 };
 
 // 상태 계산 (한국시간 기준)
-const checkSurveyActive = (_start: Date | string, _end: Date | string): SurveyActive => {
-    const now = new Date();
-    const start = new Date(_start);
-    const end = new Date(_end);
-
-    const kstNow = new Date(now.getTime() + 9 * 60 * 60 * 1000);
-
-    if (kstNow < start) return 'upcoming';
-    if (kstNow >= start && kstNow <= end) return 'ongoing';
-    return 'closed';
+const checkSurveyActive = (
+  _start: Date | string,
+  _end: Date | string
+): SurveyActive => {
+  const now = new Date();
+  const start = new Date(_start);
+  const end = new Date(_end);
+
+  const kstNow = new Date(now.getTime() + 9 * 60 * 60 * 1000);
+
+  if (kstNow < start) return "upcoming";
+  if (kstNow >= start && kstNow <= end) return "ongoing";
+  return "closed";
 };
 
 // 설문 타입 유효성 검사
 const isSurveyType = (value: any): value is SurveyType => {
-    return Object.values(SurveyType).includes(value);
+  return Object.values(SurveyType).includes(value);
 };
 
 // 설문 생성
 export const createSurvey = async ({
-    userId,
-    adminId,
-    body,
+  userId,
+  adminId,
+  body,
 }: {
-    userId?: string;
-    adminId?: string;
-    body: any;
+  userId?: string;
+  adminId?: string;
+  body: any;
 }) => {
-    try {
-        if (!userId && !adminId) {
-            throw new Error("User 또는 Admin 중 하나는 반드시 존재해야 합니다.");
-        }
+  try {
+    if (!userId && !adminId) {
+      throw new Error("User 또는 Admin 중 하나는 반드시 존재해야 합니다.");
+    }
 
-        if (userId && adminId) {
-            throw new Error("User와 Admin은 동시에 생성자로 들어올 수 없습니다.");
-        }
+    if (userId && adminId) {
+      throw new Error("User와 Admin은 동시에 생성자로 들어올 수 없습니다.");
+    }
 
-        // 타입 유효성 검사
-        if (!isSurveyType(body.type)) {
-            throw new Error(`잘못된 설문 타입 입니다: ${body.type}`);
-        }
+    // 타입 유효성 검사
+    if (!isSurveyType(body.type)) {
+      throw new Error(`잘못된 설문 타입 입니다: ${body.type}`);
+    }
 
-        // 타입 캐스팅
-        const surveyType = body.type as SurveyType;
-
-        return await prisma.$transaction(async (tx) => {
-            //  음악테이블 저장
-            const music = await tx.music.create({
-                data: {
-                    title: body.title,
-                    artist: body.artist,
-                    release_date: body.release_date ? new Date(body.release_date) : undefined,
-                    is_released: body.is_released,
-                    thumbnail_url: body.thumbnail_url,
-                    sample_url: body.sample_url,
-                    agency: '',
-                    description: '',
-                    nft_token_id: '',
-                },
-            });
-
-            // 설문태그 추출 및 필터링
-            const tagValues: SurveyTags[] = (Object.values(body.tags || {}) as string[])
-                .filter((v): v is SurveyTags =>
-                    Object.values(SurveyTags).includes(v as SurveyTags)
-                );
-
-            if (surveyType === SurveyType.official) {
-                if (
-                    body.reward == null ||
-                    body.expert_reward == null ||
-                    body.reward_amount == null
-                ) {
-                    throw new Error("공식 설문에는 reward, expert_reward, reward_amount 모두 필요합니다.");
-                }
-            }
-
-            const startDate = new Date(body.start_at);
-            const endDate = new Date(body.end_at);
-
-            // 설문 생성
-            const survey = await tx.survey.create({
-                data: {
-                    ...(userId ? { create_userId: userId } : {}),
-                    ...(adminId ? { create_adminId: adminId } : {}),
-                    music_id: music.id,
-                    type: surveyType,
-                    start_at: startDate,
-                    end_at: endDate,
-                    is_active: checkSurveyActive(startDate, endDate),
-                    tags: { set: tagValues },
-                    status: body.status ?? 'draft',
-                    survey_title: body.survey_title,
-                    template_id: body.template_id,
-
-                    ...(surveyType === SurveyType.official && {
-                        reward: body.reward,
-                        expert_reward: body.expert_reward,
-                        reward_amount: body.reward_amount,
-                    }),
-                },
-            });
-
-            // 커스텀 문항 저장
-            const questions = Array.isArray(body.allQuestions)
-                ? body.allQuestions
-                : JSON.parse(body.allQuestions);
-
-            await Promise.all(
-                questions.map((q: any, idx: number) => {
-                    return tx.survey_Custom.create({
-                        data: {
-                            survey_id: survey.id,
-                            question_text: q.text?.trim() || '(비어 있는 질문)',
-                            question_type: convertType(q.type),
-                            options: JSON.stringify(q.options ?? []),
-                            is_required: true,
-                            question_order: idx + 1,
-                        },
-                    });
-                })
-            );
-
-            console.log(':', survey.id);
-            return survey;
-        });
-    } catch (error) {
-        console.error("설문 생성 에러:", error);
-        if (error instanceof Prisma.PrismaClientKnownRequestError) {
-            console.error("Prisma Error Code:", error.code);
-            console.error("Meta:", error.meta);
+    // 타입 캐스팅
+    const surveyType = body.type as SurveyType;
+
+    return await prisma.$transaction(async (tx) => {
+      //  음악테이블 저장
+      const music = await tx.music.create({
+        data: {
+          title: body.title,
+          artist: body.artist,
+          release_date: body.release_date
+            ? new Date(body.release_date)
+            : undefined,
+          is_released: body.is_released,
+          thumbnail_url: body.thumbnail_url,
+          sample_url: body.sample_url,
+          agency: "",
+          description: "",
+          nft_token_id: "",
+        },
+      });
+
+      // 설문태그 추출 및 필터링
+      const tagValues: SurveyTags[] = (
+        Object.values(body.tags || {}) as string[]
+      ).filter((v): v is SurveyTags =>
+        Object.values(SurveyTags).includes(v as SurveyTags)
+      );
+
+      if (surveyType === SurveyType.official) {
+        if (
+          body.reward == null ||
+          body.expert_reward == null ||
+          body.reward_amount == null
+        ) {
+          throw new Error(
+            "공식 설문에는 reward, expert_reward, reward_amount 모두 필요합니다."
+          );
         }
-        throw error;
+      }
+
+      const startDate = new Date(body.start_at);
+      const endDate = new Date(body.end_at);
+
+      // 설문 생성
+      const survey = await tx.survey.create({
+        data: {
+          ...(userId ? { create_userId: userId } : {}),
+          ...(adminId ? { create_adminId: adminId } : {}),
+          music_id: music.id,
+          type: surveyType,
+          start_at: startDate,
+          end_at: endDate,
+          is_active: checkSurveyActive(startDate, endDate),
+          tags: { set: tagValues },
+          status: body.status ?? "draft",
+          survey_title: body.survey_title,
+          template_id: body.template_id,
+
+          ...(surveyType === SurveyType.official && {
+            reward: body.reward,
+            expert_reward: body.expert_reward,
+            reward_amount: body.reward_amount,
+          }),
+        },
+      });
+
+      // 커스텀 문항 저장
+      const questions = Array.isArray(body.allQuestions)
+        ? body.allQuestions
+        : JSON.parse(body.allQuestions);
+
+      await Promise.all(
+        questions.map((q: any, idx: number) => {
+          return tx.survey_Custom.create({
+            data: {
+              survey_id: survey.id,
+              question_text: q.text?.trim() || "(비어 있는 질문)",
+              question_type: convertType(q.type),
+              options: JSON.stringify(q.options ?? []),
+              is_required: true,
+              question_order: idx + 1,
+            },
+          });
+        })
+      );
+
+      console.log("설문 생성 완료:", survey.id);
+      return survey;
+    });
+  } catch (error) {
+    console.error("설문 생성 에러:", error);
+    if (error instanceof Prisma.PrismaClientKnownRequestError) {
+      console.error("Prisma Error Code:", error.code);
+      console.error("Meta:", error.meta);
     }
+    throw error;
+  }
 };
 
 // 설문 불러오기
 export const getSurveyListService = async () => {
-    return await prisma.survey.findMany({
-        include: {
-            music: true,
-            creator: {
-                select: { id: true },
-            },
-            director: {
-                select: { id: true },
-            },
-            survey_custom: true,
-        },
-        orderBy: { start_at: 'desc' },
-    });
+  return await prisma.survey.findMany({
+    include: {
+      music: true,
+      creator: {
+        select: { id: true },
+      },
+      director: {
+        select: { id: true },
+      },
+      survey_custom: true,
+    },
+    orderBy: { start_at: "desc" },
+  });
 };
 
 // 설문 정보 수정
 export const updateSurveyService = async (surveyId: number, body: any) => {
-    return await prisma.$transaction(async (tx) => {
+  return await prisma.$transaction(async (tx) => {
+    const updatedSurvey = await tx.survey.update({
+      where: { id: surveyId },
+      data: {
+        survey_title: body.survey_title,
+        start_at: new Date(body.start_at),
+        end_at: new Date(body.end_at),
+        status: body.status,
+        is_active: checkSurveyActive(body.start_at, body.end_at),
+        tags: {
+          set: (Object.values(body.tags || {}) as string[]).filter(
+            (v): v is SurveyTags =>
+              Object.values(SurveyTags).includes(v as SurveyTags)
+          ),
+        },
+        reward: body.reward,
+        reward_amount: body.reward_amount,
+        expert_reward: body.expert_reward,
+      },
+    });
 
-        const updatedSurvey = await tx.survey.update({
-            where: { id: surveyId },
+    // 기존 커스텀 문항 가져오기
+    const existingQuestions = await tx.survey_Custom.findMany({
+      where: { survey_id: surveyId },
+    });
+    const existingIds = new Set(existingQuestions.map((q) => q.id));
+
+    const incomingQuestions = Array.isArray(body.allQuestions)
+      ? body.allQuestions
+      : JSON.parse(body.allQuestions);
+
+    const incomingIds = new Set<number>();
+
+    await Promise.all(
+      incomingQuestions.map(async (q: any, idx: number) => {
+        const questionData = {
+          question_text: q.text?.trim() || "(비어 있는 질문)",
+          question_type: convertType(q.type),
+          options: JSON.stringify(q.options ?? []),
+          is_required: q.is_required ?? true,
+          question_order: idx + 1,
+        };
+
+        if (q.id && existingIds.has(q.id)) {
+          incomingIds.add(q.id);
+          await tx.survey_Custom.update({
+            where: { id: q.id },
+            data: questionData,
+          });
+        } else {
+          const created = await tx.survey_Custom.create({
             data: {
-                survey_title: body.survey_title,
-                start_at: new Date(body.start_at),
-                end_at: new Date(body.end_at),
-                status: body.status,
-                is_active: checkSurveyActive(body.start_at, body.end_at),
-                tags: {
-                    set: (Object.values(body.tags || {}) as string[]).filter(
-                        (v): v is SurveyTags => Object.values(SurveyTags).includes(v as SurveyTags)
-                    ),
-                },
-                reward: body.reward,
-                reward_amount: body.reward_amount,
-                expert_reward: body.expert_reward,
+              survey_id: surveyId,
+              ...questionData,
             },
-        });
-
-        // 기존 커스텀 문항 가져오기
-        const existingQuestions = await tx.survey_Custom.findMany({
-            where: { survey_id: surveyId },
-        });
-        const existingIds = new Set(existingQuestions.map((q) => q.id));
-
-        const incomingQuestions = Array.isArray(body.allQuestions)
-            ? body.allQuestions
-            : JSON.parse(body.allQuestions);
-
-        const incomingIds = new Set<number>();
-
-        await Promise.all(
-            incomingQuestions.map(async (q: any, idx: number) => {
-                const questionData = {
-                    question_text: q.text?.trim() || '(비어 있는 질문)',
-                    question_type: convertType(q.type),
-                    options: JSON.stringify(q.options ?? []),
-                    is_required: q.is_required ?? true,
-                    question_order: idx + 1,
-                };
-
-                if (q.id && existingIds.has(q.id)) {
-                    incomingIds.add(q.id);
-                    await tx.survey_Custom.update({
-                        where: { id: q.id },
-                        data: questionData,
-                    });
-                } else {
-                    const created = await tx.survey_Custom.create({
-                        data: {
-                            survey_id: surveyId,
-                            ...questionData,
-                        },
-                    });
-                    incomingIds.add(created.id);
-                }
-            })
-        );
-
-        const idsToDelete = [...existingIds].filter((id) => !incomingIds.has(id));
-        if (idsToDelete.length > 0) {
-            await tx.survey_Custom.deleteMany({
-                where: { id: { in: idsToDelete } },
-            });
+          });
+          incomingIds.add(created.id);
         }
+      })
+    );
+
+    const idsToDelete = [...existingIds].filter((id) => !incomingIds.has(id));
+    if (idsToDelete.length > 0) {
+      await tx.survey_Custom.deleteMany({
+        where: { id: { in: idsToDelete } },
+      });
+    }
 
-        return updatedSurvey;
-    });
-}
\ No newline at end of file
+    return updatedSurvey;
+  });
+};
